/*
* Copyright © 2017 Jesse Nicholson
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

namespace HttpFe.Common
{
    public enum ProxyNextAction
    {
        AllowAndIgnoreContent = 0,
        AllowButRequestContentInspection = 1,
        DropConnection = 2,
        AllowAndIgnoreContentAndResponse = 3
    };

    /// <summary>
    /// Callback that is designed to verify if the binary at the supplied absolute path has firewall
    /// permission to access the internet.
    /// </summary>
    public delegate bool FirewallCheckHandler(string binaryAbsolutePath);

    /// <summary>
    /// Callback for receiving informational messages. 
    /// </summary>
    public delegate void MessageHandler(string message);

    /// <summary>
    /// Callback for when a new Http message has been detected and at minimum, the headers are
    /// guaranteed to be parsed.
    /// </summary>
    /// <param name="requestHeaders">
    /// The request headers. Guaranteed to be populated. 
    /// </param>
    /// <param name="requestBody">
    /// The request body. May be populated if the request was completely parsed. 
    /// </param>
    /// <param name="responseHeaders">
    /// The response headers. Will only be populated if this is a response itself, in which case they
    /// are guaranteed to be fully populated. Otherwise, they are guaranteed to be completely empty.
    /// </param>
    /// <param name="responseBody">
    /// The response body. Will only be populated if this is a response itself, and if the entire
    /// response was parsed already. Otherwise, is guaranteed to be empty.
    /// </param>
    /// <param name="nextAction">
    /// Out parameter to control the next action that the proxy is to take after this callback has completed. 
    /// </param>
    /// <param name="customBlockResponseData">
    /// If next action is set to block, this can be arbitrary content you want to populate the block
    /// action response. If you use this, it must include any headers as well, a complete Http
    /// message. If you do not wish to use this, simply supply null and a default value will used.
    /// </param>
    public delegate void HttpMessageBeginHandler(
        string requestHeaders, byte[] requestBody,
        string responseHeaders, byte[] responseBody,
        out ProxyNextAction nextAction, out byte[] customBlockResponseData
    );

    /// <summary>
    /// Called only for transactions that were flagged for inspection. In this callback, the request
    /// headers, body, response headers and body are all guaranteed to be populated, as this is a
    /// complete, final Http transaction for final content inspection.
    /// </summary>
    /// <param name="requestHeaders">
    /// The complete request headers. Guaranteed to be populated. 
    /// </param>
    /// <param name="requestBody">
    /// The complete request body. Guaranteed to be populated. 
    /// </param>
    /// <param name="responseHeaders">
    /// The complete response headers. Guaranteed to be populated. 
    /// </param>
    /// <param name="responseBody">
    /// The complete response body. Guaranteed to be populated. 
    /// </param>
    /// <param name="shouldBlock">
    /// An out parameter to dictate whether or not this transaction should be blocked. 
    /// </param>
    /// <param name="customBlockResponseData">
    /// If shouldBlock is set to true, this can be arbitrary content you want to populate the block
    /// action response. If you use this, it must include any headers as well, a complete Http
    /// message. If you do not wish to use this, simply supply null and a default value will used.
    /// </param>
    public delegate void HttpMessageEndHandler(
        string requestHeaders, byte[] requestBody,
        string responseHeaders, byte[] responseBody,
        out bool shouldBlock, out byte[] customBlockResponseData
    );

    public interface IHttpFilteringEngine
    {
        string CaBundleAbsolutePath
        {
            get;
        }

        ushort HttpListenerPort
        {
            get;
        }

        ushort HttpsListenerPort
        {
            get;
        }

        bool IsRunning
        {
            get;
        }

        byte[] RootCaPEM
        {
            get;
        }

        /// <summary>
        /// Called whenever informational messages about non-critical events are generated by
        /// the Engine.
        /// </summary>
        event MessageHandler OnInfo;

        /// <summary>
        /// Called whenever informational messages about warnings are generated by the Engine.
        /// </summary>
        event MessageHandler OnWarning;

        /// <summary>
        /// Called whenever informational messages about handled errors are generated by the
        /// Engine.
        /// </summary>
        event MessageHandler OnError;

        void Start();

        void Stop();        
    }
}